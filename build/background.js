const h=typeof self<"u"&&self.browser?self.browser:chrome,d=new Map,u=new Map;let f;function S(){f=setInterval(()=>{},2e4)}h.runtime.onInstalled.addListener(()=>{S()});h.runtime.onMessage.addListener((e,t,r)=>{switch(e.type){case"GET_WALLET_STATE":return y(r),!0;case"SIGN_TRANSACTION":return T(e.data,r),!0;case"SEND_TRANSACTION":return N(e.data,t,r),!0;case"GET_ACCOUNTS":return E(r),!0;case"REQUEST_ACCOUNTS":return A(t,r),!0;case"APPROVE_CONNECTION":return _(e.tabId,e.accounts),!1;case"REJECT_CONNECTION":return v(e.tabId),!1;case"APPROVE_TRANSACTION":return p(e.tabId,e.transaction),!1;case"REJECT_TRANSACTION":return C(e.tabId),!1;case"SWITCH_NETWORK":return I(e.data,r),!0;default:r({error:"Unknown message type"})}return!1});async function y(e){try{const t=await chrome.storage.local.get(["walletState","selectedNetwork"]);e({success:!0,data:{walletState:t.walletState||null,selectedNetwork:t.selectedNetwork||"sepolia"}})}catch(t){e({success:!1,error:t.message})}}async function T(e,t){try{t({success:!0,message:"Transaction signing requested"})}catch(r){t({success:!1,error:r.message})}}async function N(e,t,r){var c,o;try{const s=(c=t.tab)==null?void 0:c.id,l=(o=t.tab)!=null&&o.url?new URL(t.tab.url).origin:"Unknown";if(!s){r({success:!1,error:"Cannot identify sender tab."});return}u.set(s,r);const n=encodeURIComponent(JSON.stringify(e));chrome.windows.create({url:`transaction.html?tabId=${s}&origin=${encodeURIComponent(l)}&tx=${n}`,type:"popup",width:420,height:700})}catch(s){r({success:!1,error:s.message})}}async function E(e){try{const r=(await chrome.storage.local.get(["walletState"])).walletState;if(!r||!r.evmAddress){e({success:!0,accounts:[]});return}e({success:!0,accounts:[r.evmAddress]})}catch(t){e({success:!1,error:t.message})}}async function A(e,t){var r,c;try{const s=await chrome.storage.local.get(["devnet_wallet_session","walletState"]);let l=null;if(s.walletState&&s.walletState.evmAddress&&(l=s.walletState.evmAddress),!l){t({success:!1,error:"Wallet is locked or not initialized. Please unlock your DevNet Wallet."});return}const n=(r=e.tab)==null?void 0:r.id,i=(c=e.tab)!=null&&c.url?new URL(e.tab.url).origin:"Unknown";if(!n){t({success:!1,error:"Cannot identify sender tab."});return}d.set(n,t),chrome.windows.create({url:`approval.html?tabId=${n}&origin=${encodeURIComponent(i)}`,type:"popup",width:400,height:600})}catch(o){t({success:!1,error:o.message})}}function _(e,t){const r=d.get(e);r&&(r({success:!0,accounts:t}),d.delete(e))}function v(e){const t=d.get(e);t&&(t({success:!1,error:"User rejected the connection request."}),d.delete(e))}async function p(e,t){const r=u.get(e);if(r)try{const c="devnet_wallet_session",s=(await chrome.storage.local.get([c]))[c];if(!s||!s.data||!s.data.evmPrivateKey)throw new Error("Wallet is locked. Please unlock your wallet.");const l=chrome.runtime.getURL("signer.html"),n=Date.now().toString();await chrome.storage.local.set({pendingSignerTransaction:{transaction:t,privateKey:s.data.evmPrivateKey,requestId:n}});const i=await chrome.windows.create({url:l,type:"popup",width:1,height:1,left:-9999,top:-9999,focused:!1}),g=async()=>{for(let a=0;a<300;a++){await new Promise(m=>setTimeout(m,100));const w=await chrome.storage.local.get([`signerResult_${n}`]);if(w[`signerResult_${n}`])return await chrome.storage.local.remove([`signerResult_${n}`]),w[`signerResult_${n}`]}throw new Error("Signer timeout after 30 seconds")};try{const a=await g();if(i.id)try{await chrome.windows.remove(i.id)}catch{}a&&a.success?r({success:!0,hash:a.hash,pending:a.pending||!1}):r({success:!1,error:(a==null?void 0:a.error)||"Transaction failed",hash:a==null?void 0:a.hash})}catch(a){if(i.id)try{await chrome.windows.remove(i.id)}catch{}r({success:!1,error:a.message||"Transaction signing failed"})}u.delete(e)}catch(c){r({success:!1,error:c.message}),u.delete(e)}}function C(e){const t=u.get(e);t&&(t({success:!1,error:"User rejected the transaction."}),u.delete(e))}async function I(e,t){try{await chrome.storage.local.set({selectedNetwork:e.network}),(await chrome.tabs.query({})).forEach(c=>{c.id&&chrome.tabs.sendMessage(c.id,{type:"NETWORK_CHANGED",network:e.network}).catch(()=>{})}),t({success:!0})}catch(r){t({success:!1,error:r.message})}}self.addEventListener("beforeunload",()=>{f&&clearInterval(f)});
